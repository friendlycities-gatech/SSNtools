#----------------------------------------------#
#-----Import Utility Functions ----------------#
#----------------------------------------------#
source("utils.R")

#----------------------------------------------#
# -----Process input data to correct format ---#
#----------------------------------------------#

#------Each node is stored a named list ------#
#------nodes is a list of named list ---------#
#=-----The process returns a list of named lists with the named key as label
data = read.csv('/Users/xiaofanliang/Dropbox (GaTech)/GT_Research/Edge_Scan/Filtered_MafiaNodes.csv')
data = read.csv('/Users/xiaofanliang/Dropbox (GaTech)/GT_Research/Edge_Scan/Filtered_MafiaEdges.csv')

nodes = processNode(data, 'label', 'lon', 'lat')
edges = processEdge(data, 'Source', 'Target')

#data: R dataframe 
#label_name: a string that indicate the column with node label 
#lon_name: a float that indicates the column with longitude 
#lat_name: a float that indicates the column with latitude 
processNode = function(data, label_name, lon_name, lat_name) {
  #convert columns to the right data format
  names(data)[names(data) == label_name] <- "label"
  names(data)[names(data) == lon_name] <- "lon"
  names(data)[names(data) == lat_name] <- "lat"
  data$label = as.character(data$label)
  data$lon = as.numeric(as.character(data$lon))
  data$lat = as.numeric(as.character(data$lat))
  
  #convert data frame to a list of named lists
  data2 = as.list(data)
  nodes = list()
  
  for (i in 1:nrow(data)) {
    temp = list()
    label = as.character(data2$label[i])
    node = list('label' = label, 'lon' = data2$lon[i], 'lat'= data2$lat[i])
    temp[[label]] <- node #this is the only way to assign key by variable name
    nodes = append(nodes, temp)
  }
  return(nodes)
}

#To retrieve one node with key
#nodes[[1]]

#To retrieve the values of a node 
#nodes[['YOUR LABEL']][['label']]

#data: R dataframe 
#source_name: a string that indicates the column with the source node label 
#target_name: a string that indicates the column with the target node label
processEdge = function(data, source_name, target_name) {
  data$Source = as.character(data$Source)
  data$Target = as.character(data$Target)
  
  data2 = as.list(data)
  edges = list()
  
  for (i in 1:nrow(data)) {
    edge = list('Source' = data2$Source[i], 'Target' = data2$Target[i]) #this is the only way to assign key by variable name
    edges[[length(edges) + 1]] = edge
  }
  return(edges)
}

#------------------------------------------#
#---------------Main Functions ------------#
#------------------------------------------#

# edgeScan - generates heatmap of edges within maxRadius of every node in a graph
# params:
#     nodes - nodes of graph
#     edges - edges of graph
#     maxRadius - radius in km of search window

edgeScanRadius = function(nodes, edges, maxRadius) {
  visitedNodes = list()
  labels = c()
  numedges = c()
  
  runningNode = nodes[[1]]
  while (length(visitedNodes) < length(nodes)) { 
    numEdges = getNumEdgesInRange(edges, runningNode, maxRadius)
    
    labels = c(labels, runningNode[['label']])
    numedges = c(numedges, numEdges)
    
    temp = list()
    temp[[runningNode[['label']]]] <- runningNode
    visitedNodes = append(visitedNodes, temp)
    runningNode = nearestUnvisitedNeighbor(nodes, visitedNodes, runningNode)
  }
  heat = data.frame('label' = labels, 'heat' = numedges)
  return(heat)
}

# edgeScan - generates heatmap of edges between k nearest nodes to each independent node in a graph
# params:
#     nodes - nodes of graph
#     edges - edges of graph
#     k - number of nodes in search window

edgeScanKNearest = function(nodes, edges, k) {
  visitedNodes = list()
  labels = c()
  numedges = c()
  
  runningNode = nodes[[1]]
  while (length(visitedNodes) < length(nodes)) {
    kNearest = nearestNeighbors(nodes, runningNode, k)
    rad = 0 
    for (node in kNearest) {
      if (euclidDistance(node, runningNode) > rad) {
        rad = euclidDistance(node, runningNode)
      }
    }
    numEdges = getNumEdgesInRange(edges, runningNode, rad)
    
    labels = c(labels, runningNode[['label']])
    numedges = c(numedges, numEdges)
    
    temp = list()
    temp[[runningNode[['label']]]] <- runningNode
    visitedNodes = append(visitedNodes, temp)
    runningNode = nearestUnvisitedNeighbor(nodes, visitedNodes, runningNode)
  }
  heat = data.frame('label' = labels, 'heat' = numedges)
  return(heat)
}

# edgeScan - generates heatmap of edges within manhattan distance of every node in a graph
# params:
#     nodes - nodes of graph
#     edges - edges of graph
#     distance - manhattan distance in km of search window
edgeScanManhattan = function(nodes, edges, distance) {
  visitedNodes = list()
  labels = c()
  numedges = c()
  runningNode = nodes[[1]]
  while (length(visitedNodes) < length(nodes)) {
    numEdges = numberEdgesWithinManhattanDistance(nodes, edges, runningNode, distance)
    labels = c(labels, runningNode[['label']])
    numedges = c(numedges, numEdges)
    temp = list()
    temp[[runningNode[['label']]]] <- runningNode
    visitedNodes = append(visitedNodes, temp)
    runningNode = nearestUnvisitedNeighbor(nodes, visitedNodes, runningNode)
  }
  heat = data.frame('label' = labels, 'heat' = numedges)
  return(heat)
}


# NDScan - calculates network density within a radius of each node in a network.
# This is the ratio between the Actual Connections and the Potential Connections in a network.
# 
# Below are the three implementations of this, using radius, K-nearest, and Manhattan distance metrics.
NDScanRadius = function(nodes, edges, radius) {
  visitedNodes = list()
  labels = c()
  ndensity = c()
  runningNode = nodes[[1]]
  
  while (length(visitedNodes) < length(nodes)) {
    #print(length(visitedNodes)/length(nodes))
    numNodesInRadius = numberNodesWithinRadius(nodes, runningNode, radius)
    potential = numNodesInRadius * (numNodesInRadius - 1)/2
    numEdges = getNumEdgesInRange(edges, runningNode, radius)
    
    if (numNodesInRadius < 3) {
      labels = c(labels, runningNode[['label']])
      ndensity = c(ndensity, 0)
    } else {
      nDensity = numEdges / potential 
      labels = c(labels, runningNode[['label']])
      ndensity = c(ndensity, nDensity)
      if (nDensity > 1) {
        print("Node in Question: ", runningNode)
        print("Num nodes in radius (including source): ", numNodesInRadius)
        print("Num Edges in radius: ", numEdges)
        print("Potential Edges: ", potential)
      }
    }
    temp = list()
    temp[[runningNode[['label']]]] <- runningNode
    visitedNodes = append(visitedNodes, temp)
    runningNode = nearestUnvisitedNeighbor(nodes, visitedNodes, runningNode)
  }
  heat = data.frame('label' = labels, 'heat' = ndensity)
  return(heat)
}

NDScanKNearest = function(nodes, edges, k) {
  visitedNodes = list()
  labels = c()
  ndensity = c()
  runningNode = nodes[[1]]
  
  while (length(visitedNodes) < length(nodes)) {
    kNearest = nearestNeighbors(nodes, runningNode, k)
    rad = 0
    for (node in kNearest) {
      if (euclidDistance(runningNode, node) > rad) {
        rad = euclidDistance(runningNode, node)
      }
    }
    numEdges = getNumEdgesInRange(edges, runningNode, rad)
    potentialEdges = (k + 1)*k/2
    nDensity = numEdges/potentialEdges
    
    labels = c(labels, runningNode[['label']])
    ndensity = c(ndensity, nDensity)
    
    temp = list()
    temp[[runningNode[['label']]]] <- runningNode
    visitedNodes = append(visitedNodes, temp)
    runningNode = nearestUnvisitedNeighbor(nodes, visitedNodes, runningNode)
  }
  heat = data.frame('label' = labels, 'heat' = ndensity)
  return(heat)
}

NDScanManhattan = function(nodes, edges, distance) {
  visitedNodes = list()
  labels = c()
  ndensity = c()
  runningNode = nodes[[1]]
  
  while (length(visitedNodes) < length(nodes)) {
    numNodesInManhattanDistance = numberNodesWithinManhattanDistance(nodes, runningNode, distance)
    edgesInManhattanDistance = getEdgesInManhattanDistance(edges, runningNode, distance)
    #nodesInManhattanDistance = getNodesInManhattanDistance(nodes, runningNode, distance)
    
    potentialEdges = numNodesInManhattanDistance * (numNodesInManhattanDistance - 1) / 2
    numEdges = numberEdgesWithinManhattanDistance(nodes, edges, runningNode, distance)
    
    if (numNodesInManhattanDistance < 3) {
      labels = c(labels, runningNode[['label']])
      ndensity = c(ndensity, 0)
    } else {
      nDensity = numEdges/potentialEdges
      labels = c(labels, runningNode[['label']])
      ndensity = c(ndensity, nDensity)
    }
    temp = list()
    temp[[runningNode[['label']]]] <- runningNode
    visitedNodes = append(visitedNodes, temp)
    runningNode = nearestUnvisitedNeighbor(nodes, visitedNodes, runningNode)
  }
  heat = data.frame('label' = labels, 'heat' = ndensity)
  return(heat)
}


  
#----TEST CODES ------#
kk = edgeScanRadius(nodes, edges, 500)
sum(kk$heat)
kk = edgeScanKNearest(nodes, edges, 10)
sum(kk$heat)
kk = edgeScanManhattan(nodes, edges, 500)
sum(kk$heat)
kk = NDScanRadius(nodes, edges, 500)
sum(kk$heat)
kk = NDScanKNearest(nodes, edges, 10)
sum(kk$heat)
kk = NDScanManhattan(nodes, edges, 500)
sum(kk$heat)



#return a list of lists.
data = read.csv('/Users/xiaofanliang/Dropbox (GaTech)/GT_Research/Edge_Scan/Filtered_MafiaEdges.csv')
data$Source = as.character(data$Source)
data$Target = as.character(data$Target)
  
data2 = as.list(data)
edges = list()

for (i in 1:nrow(data)) {
  edge = list('Source' = data2$Source[i], 'Target' = data2$Target[i]) #this is the only way to assign key by variable name
  edges[[length(edges) + 1]] = edge
}

#To retrieve one edge 
edges[[1]]

#To retrieve the value of an edge 
nodes[[1]][['Source']]

#edges = edges %>% 
#  mutate(ID = row_number()) %>% 
#  group_split(ID, .keep=FALSE)
#edges[[1]]

# ---- EXPORT FILTERED NODES -----#
library(openxlsx)
data = read.xlsx('/Users/xiaofanliang/Dropbox (GaTech)/GT_Research/Edge_Scan/TheData.xlsx')
nodes = data %>% select(c(Label, Lat, Lon)) %>% slice(1:298) %>% 
  rename(lon=Lon, lat=Lat, label=Label) %>% 
  #read.csv('/Users/xiaofanliang/Dropbox (GaTech)/GT_Research/Edge_Scan/MafiaNodes.csv') %>% 
  #filter(NODE %in% data$Label) %>% 
  #rename(lon=LonX, lat=LatY, label=NODE) %>% 
  mutate(label = as.character(label)) %>% 
  select(c(label, lon, lat)) %>% 
  st_as_sf(coords=c('lon', 'lat'), crs=4326) %>% 
  st_transform(crs=32118) %>% #NAD 83: New York Long Island Unit Meter 
  mutate(lon = sf::st_coordinates(.)[,2], lat = sf::st_coordinates(.)[,1]) %>% 
  st_drop_geometry()

write.csv(nodes, file='/Users/xiaofanliang/Dropbox (GaTech)/GT_Research/Edge_Scan/Filtered_MafiaNodes.csv', row.names = FALSE)

#946 rather than 936. 
edges = read.csv('/Users/xiaofanliang/Dropbox (GaTech)/GT_Academics/Spatial_Networks/MafiaLab/MafiaEdges.csv') %>% 
  filter((Source %in% data$Label) & (Target %in% data$Label) & (Source != Target)) %>% 
  distinct_at(vars(Source, Target)) %>% 
  graph_from_data_frame(directed=FALSE)

edges = as.data.frame(get.edgelist(edges)) %>% distinct_at(vars(V1, V2)) %>% 
  rename(Source = V1, Target = V2)

write.csv(edges, file='/Users/xiaofanliang/Dropbox (GaTech)/GT_Research/Edge_Scan/Filtered_MafiaEdges.csv', row.names = FALSE)



