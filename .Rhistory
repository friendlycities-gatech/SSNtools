}
labels = c()
numedges = c()
if(bipartite) {
if (is.null(nodes[[1]][['bipartite']])) {
stop('Node bipartite value is not available. Please check if node table contains a bipartite column and if the name of the bipartite column is provided in the processNode function')}
#sort so that bipartite == 1 is on top.
nodes = nodes[order(-sapply(nodes, function(x) x[['bipartite']]))]
stop = length(Filter(function(x) all((x <- x$bipartite == 1)), nodes))
} else {
stop = length(nodes)
}
for (i in seq(1, stop)) {
numNodesInRadius = numberNodesWithinRadius(nodes, nodes[[i]], radius, bipartite)
if (numNodesInRadius < min) {
labels = c(labels, nodes[[i]][['label']])
numedges = c(numedges, NA)
} else {
numEdges = getNumEdgesInRange(nodes, edges, nodes[[i]], radius, weighted)
labels = c(labels, nodes[[i]][['label']])
numedges = c(numedges, numEdges)
}
}
heat = data.frame('label' = labels, 'heat' = numedges)
if(abs(nodes[[1]][['lat']]) <= 180) {
warning("Distance may be calculated in the degree coordinates, which may need to be projected into other distance units")
}
source = c()
target = c()
weight = c()
withinwindow = c()
for (edge in edges) {
source = c(source, edge[['Source']])
target = c(target, edge[['Target']])
if(weighted) {weight = c(weight, edge[['Weight']])}
if (euclidDistance(nodes[[edge[['Source']]]], nodes[[edge[['Target']]]]) < radius) {
withinwindow = c(withinwindow, 1)
} else {
withinwindow = c(withinwindow, 0)
}
}
if(weighted) {
edgeWithin = data.frame('Source' = source, 'Target' = target, 'Weight' = weight, 'WithinWindow' = withinwindow)
} else {
edgeWithin = data.frame('Source' = source, 'Target' = target, 'WithinWindow' = withinwindow)
}
return(list(heat, edgeWithin))
}
# edgeScan - generates heatmap of edges between k nearest nodes to each independent node in a graph
# params:
#     nodes - nodes of graph
#     edges - edges of graph
#     k - number of nodes in search window
edgeScanKNearest = function(nodes, edges, k, weighted=FALSE, bipartite=FALSE) {
if(!inherits(nodes, "list") | !inherits(edges, "list")) {
stop('nodes or edges arguments only intake a list of lists. Please use processNode or processEdge functions to convert R dataframe to a list of lists')
}
labels = c()
numedges = c()
if(bipartite) {
if (is.null(nodes[[1]][['bipartite']])) {
stop('Node bipartite value is not available. Please check if node table contains a bipartite column and if the name of the bipartite column is provided in the processNode function')}
#sort so that bipartite == 1 is on top.
nodes = nodes[order(-sapply(nodes, function(x) x[['bipartite']]))]
stop = length(Filter(function(x) all((x <- x$bipartite == 1)), nodes))
} else {
stop = length(nodes)
}
for (i in seq(1, stop)) {
kNearest = nearestNeighbors(nodes, nodes[[i]], k, bipartite)
rad = 0
for (node in kNearest) {
if (euclidDistance(node, nodes[[i]]) > rad) {
rad = euclidDistance(node, nodes[[i]])
}
}
numEdges = getNumEdgesInRange(nodes, edges, nodes[[i]], rad, weighted)
labels = c(labels, nodes[[i]][['label']])
numedges = c(numedges, numEdges)
}
heat = data.frame('label' = labels, 'heat' = numedges)
source = c()
target = c()
weight = c()
withinwindow = c()
for (edge in edges) {
source = c(source, edge[['Source']])
target = c(target, edge[['Target']])
if(weighted) {weight = c(weight, edge[['Weight']])}
#bipartite assumes source node is the one with heat values
if(bipartite) {
if (edge[['Target']] %in% sapply(nearestNeighbors(nodes, nodes[[edge[['Source']]]], k, bipartite), function(x) x[['label']])) {
withinwindow = c(withinwindow, 1)
} else {
withinwindow = c(withinwindow, 0)
}
} else {
if (edge[['Target']] %in% sapply(nearestNeighbors(nodes, nodes[[edge[['Source']]]], k, bipartite), function(x) x[['label']]) |
edge[['Source']] %in% sapply(nearestNeighbors(nodes, nodes[[edge[['Target']]]], k, bipartite), function(x) x[['label']])) {
withinwindow = c(withinwindow, 1)
} else {
withinwindow = c(withinwindow, 0)
}
}
}
if(weighted) {
edgeWithin = data.frame('Source' = source, 'Target' = target, 'Weight' = weight, 'WithinWindow' = withinwindow)
} else {
edgeWithin = data.frame('Source' = source, 'Target' = target, 'WithinWindow' = withinwindow)
}
return(list(heat, edgeWithin))
}
# edgeScan - generates heatmap of edges within manhattan distance of every node in a graph
# params:
#     nodes - nodes of graph
#     edges - edges of graph
#     radius - manhattan distance in km of search window
edgeScanManhattan = function(nodes, edges, radius, min=3, weighted=FALSE, bipartite=FALSE) {
if(!inherits(nodes, "list") | !inherits(edges, "list")) {
stop('nodes or edges arguments only intake a list of lists. Please use processNode or processEdge functions to convert R dataframe to a list of lists')
}
labels = c()
numedges = c()
if(bipartite) {
if (is.null(nodes[[1]][['bipartite']])) {
stop('Node bipartite value is not available. Please check if node table contains a bipartite column and if the name of the bipartite column is provided in the processNode function')}
#sort so that bipartite == 1 is on top.
nodes = nodes[order(-sapply(nodes, function(x) x[['bipartite']]))]
stop = length(Filter(function(x) all((x <- x$bipartite == 1)), nodes))
} else {
stop = length(nodes)
}
for (i in seq(1, stop)) {
numNodesInManhattanDistance = numberNodesWithinManhattanDistance(nodes, nodes[[i]], radius, bipartite)
if (numNodesInManhattanDistance < min) {
labels = c(labels, nodes[[i]][['label']])
numedges = c(numedges, NA)
} else {
numEdges = numberEdgesWithinManhattanDistance(nodes, edges, nodes[[i]], radius, weighted)
labels = c(labels, nodes[[i]][['label']])
numedges = c(numedges, numEdges)
}
}
heat = data.frame('label' = labels, 'heat' = numedges)
if(abs(nodes[[1]][['lat']]) <= 180) {
warning("Distance may be calculated in the degree coordinates, which may need to be projected into other distance units")
}
source = c()
target = c()
weight = c()
withinwindow = c()
for (edge in edges) {
source = c(source, edge[['Source']])
target = c(target, edge[['Target']])
if(weighted) {weight = c(weight, edge[['Weight']])}
if (ManhattanDistance(nodes[[edge[['Source']]]], nodes[[edge[['Target']]]]) < radius) {
withinwindow = c(withinwindow, 1)
} else {
withinwindow = c(withinwindow, 0)
}
}
if(weighted) {
edgeWithin = data.frame('Source' = source, 'Target' = target, 'Weight' = weight, 'WithinWindow' = withinwindow)
} else {
edgeWithin = data.frame('Source' = source, 'Target' = target, 'WithinWindow' = withinwindow)
}
return(list(heat, edgeWithin))
}
edgeScanMatrix = function(nodes, edges, thres, matrix, min=3, weighted=FALSE, bipartite=FALSE) {
if(!inherits(nodes, "list") | !inherits(edges, "list")) {
stop('nodes or edges arguments only intake a list of lists. Please use processNode or processEdge functions to convert R dataframe to a list of lists')
}
if(!inherits(matrix, "matrix")) {
stop('Your matrix input is not recognized as a matrix in R. Please check R matrix formats and make sure you have row and column names for the matrix.')
}
if(!is.null(nodes[[1]][['bipartite']]) & !bipartite) {
stop('Your data has a bipartite column, but your bipartite argument is set to FALSE. Please set your bipartite argument to TRUE')
}
labels = c()
numedges = c()
if(bipartite) {
if (is.null(nodes[[1]][['bipartite']])) {
stop('Node bipartite value is not available. Please check if node table contains a bipartite column and if the name of the bipartite column is provided in the processNode function')}
#sort so that bipartite == 1 is on top.
nodes = nodes[order(-sapply(nodes, function(x) x[['bipartite']]))]
stop = length(Filter(function(x) all((x <- x$bipartite == 1)), nodes))
#calculate the number of nodes with bipartite == 1
bipartite_num = sum(as.numeric(unlist(nodes)[grepl(pattern='bipartite', names(unlist(nodes)))]))
bipartite_trans_matrix = matrix
#assign node pairs in the same set with values of 0
bipartite_trans_matrix[1:bipartite_num, 1:bipartite_num] <- NA
bipartite_trans_matrix[(bipartite_num+1):length(nodes), (bipartite_num+1):length(nodes)] <- NA
} else {
stop = length(nodes)
}
for (i in seq(1, stop)) {
if(bipartite){
NodesInMatrix = NodesWithinMatrixThres(nodes[[i]][['label']], thres, bipartite_trans_matrix)
} else {
NodesInMatrix = NodesWithinMatrixThres(nodes[[i]][['label']], thres, matrix)
}
numNodesInMatrix = length(NodesInMatrix) + 1 #adding self node
if (numNodesInMatrix < min) {
labels = c(labels, nodes[[i]][['label']])
numedges = c(numedges, NA)
} else {
numEdges = getNumEdgesInMatrix(nodes[[i]][['label']], names(NodesInMatrix), edges, weighted)
labels = c(labels, nodes[[i]][['label']])
numedges = c(numedges, numEdges)
}
}
heat = data.frame('label' = labels, 'heat' = numedges)
if(abs(nodes[[1]][['lat']]) <= 180) {
warning("Distance may be calculated in the degree coordinates, which may need to be projected into other distance units")
}
source = c()
target = c()
weight = c()
withinwindow = c()
for (edge in edges) {
source = c(source, edge[['Source']])
target = c(target, edge[['Target']])
if(weighted) {weight = c(weight, edge[['Weight']])}
if (edge[['Target']] %in% names(NodesWithinMatrixThres(edge[['Source']], thres, matrix))) {
withinwindow = c(withinwindow, 1)
} else {
withinwindow = c(withinwindow, 0)
}
}
if(weighted) {
edgeWithin = data.frame('Source' = source, 'Target' = target, 'Weight' = weight, 'WithinWindow' = withinwindow)
} else {
edgeWithin = data.frame('Source' = source, 'Target' = target, 'WithinWindow' = withinwindow)
}
return(list(heat, edgeWithin))
}
# NDScan - calculates network density within a radius of each node in a network.
# This is the ratio between the Actual Connections and the Potential Connections in a network.
#
# Below are the three implementations of this, using radius, K-nearest, and Manhattan distance metrics.
NDScanRadius = function(nodes, edges, radius, min=3, directed=FALSE, bipartite=FALSE) {
if(!inherits(nodes, "list") | !inherits(edges, "list")) {
stop('nodes or edges arguments only intake a list of lists. Please use processNode or processEdge functions to convert R dataframe to a list of lists')
}
labels = c()
ndensity = c()
if(bipartite) {
if (is.null(nodes[[1]][['bipartite']])) {
stop('Node bipartite value is not available. Please check if node table contains a bipartite column and if the name of the bipartite column is provided in the processNode function')}
#sort so that bipartite == 1 is on top.
nodes = nodes[order(-sapply(nodes, function(x) x[['bipartite']]))]
stop = length(Filter(function(x) all((x <- x$bipartite == 1)), nodes))
} else {
stop = length(nodes)
}
for (i in seq(1, stop)) {
numNodesInRadius = numberNodesWithinRadius(nodes, nodes[[i]], radius, bipartite)
if (numNodesInRadius < min) {
labels = c(labels, nodes[[i]][['label']])
ndensity = c(ndensity, NA)
} else {
if(bipartite) {
if(directed) {dir = 2} else {dir = 1}
potential = numNodesInRadius * (numberNodesWithinRadius(nodes, nodes[[i]], radius, FALSE) - numNodesInRadius) * dir
} else {
if(directed) {dir = 1} else {dir = 2}
potential = numNodesInRadius * (numNodesInRadius - 1)/dir
}
numEdges = getNumEdgesInRange(nodes, edges, nodes[[i]], radius, FALSE) #weighted = FALSE for network density
nDensity = numEdges / potential
labels = c(labels, nodes[[i]][['label']])
ndensity = c(ndensity, nDensity)
if (nDensity > 1) {stop(paste0('Node', i, ' network density is greater than 1'))}
}
}
heat = data.frame('label' = labels, 'heat' = ndensity)
if(abs(nodes[[1]][['lat']]) <= 180) {
warning("Distance may be calculated in the degree coordinates, which may need to be projected into other distance units")
}
source = c()
target = c()
withinwindow = c()
for (edge in edges) {
source = c(source, edge[['Source']])
target = c(target, edge[['Target']])
if (euclidDistance(nodes[[edge[['Source']]]], nodes[[edge[['Target']]]]) < radius) {
withinwindow = c(withinwindow, 1)
} else {
withinwindow = c(withinwindow, 0)
}
}
edgeWithin = data.frame('Source' = source, 'Target' = target, 'WithinWindow' = withinwindow)
return(list(heat, edgeWithin))
}
NDScanKNearest = function(nodes, edges, k, directed=FALSE, bipartite=FALSE) {
if(!inherits(nodes, "list") | !inherits(edges, "list")) {
stop('nodes or edges arguments only intake a list of lists. Please use processNode or processEdge functions to convert R dataframe to a list of lists')
}
labels = c()
ndensity = c()
if(bipartite) {
if (is.null(nodes[[1]][['bipartite']])) {
stop('Node bipartite value is not available. Please check if node table contains a bipartite column and if the name of the bipartite column is provided in the processNode function')}
#sort so that bipartite == 1 is on top.
nodes = nodes[order(-sapply(nodes, function(x) x[['bipartite']]))]
stop = length(Filter(function(x) all((x <- x$bipartite == 1)), nodes))
} else {
stop = length(nodes)
}
for (i in seq(1, stop)) {
kNearest = nearestNeighbors(nodes, nodes[[i]], k, bipartite)
rad = 0
for (node in kNearest) {
if (euclidDistance(nodes[[i]], node) > rad) {
rad = euclidDistance(nodes[[i]], node)
}
}
numNodesInRadius = numberNodesWithinRadius(nodes, nodes[[i]], rad, bipartite)
if(bipartite) {
if(directed) {dir = 2} else {dir = 1}
potential = numNodesInRadius * (numberNodesWithinRadius(nodes, nodes[[i]], rad, FALSE) - numNodesInRadius) * dir
} else {
if(directed) {dir = 1} else {dir = 2}
potential = numNodesInRadius * (numNodesInRadius - 1)/dir
}
numEdges = getNumEdgesInRange(nodes, edges, nodes[[i]], rad, FALSE) #weighted = FALSE for network density
nDensity = numEdges / potential
labels = c(labels, nodes[[i]][['label']])
ndensity = c(ndensity, nDensity)
if (nDensity > 1) {stop(paste0('Node', i, ' network density is greater than 1'))}
}
heat = data.frame('label' = labels, 'heat' = ndensity)
source = c()
target = c()
withinwindow = c()
for (edge in edges) {
source = c(source, edge[['Source']])
target = c(target, edge[['Target']])
#bipartite assumes source node is the one with heat values
if(bipartite) {
if (edge[['Target']] %in% sapply(nearestNeighbors(nodes, nodes[[edge[['Source']]]], k, bipartite), function(x) x[['label']])) {
withinwindow = c(withinwindow, 1)
} else {
withinwindow = c(withinwindow, 0)
}
} else {
if (edge[['Target']] %in% sapply(nearestNeighbors(nodes, nodes[[edge[['Source']]]], k, bipartite), function(x) x[['label']]) |
edge[['Source']] %in% sapply(nearestNeighbors(nodes, nodes[[edge[['Target']]]], k, bipartite), function(x) x[['label']])) {
withinwindow = c(withinwindow, 1)
} else {
withinwindow = c(withinwindow, 0)
}
}
}
edgeWithin = data.frame('Source' = source, 'Target' = target, 'WithinWindow' = withinwindow)
return(list(heat, edgeWithin))
}
NDScanManhattan = function(nodes, edges, radius, min=3, directed=FALSE, bipartite=FALSE) {
if(!inherits(nodes, "list") | !inherits(edges, "list")) {
stop('nodes or edges arguments only intake a list of lists. Please use processNode or processEdge functions to convert R dataframe to a list of lists')
}
labels = c()
ndensity = c()
if(bipartite) {
if (is.null(nodes[[1]][['bipartite']])) {
stop('Node bipartite value is not available. Please check if node table contains a bipartite column and if the name of the bipartite column is provided in the processNode function')}
#sort so that bipartite == 1 is on top.
nodes = nodes[order(-sapply(nodes, function(x) x[['bipartite']]))]
stop = length(Filter(function(x) all((x <- x$bipartite == 1)), nodes))
} else {
stop = length(nodes)
}
for (i in seq(1, stop)) {
numNodesInManhattanDistance = numberNodesWithinManhattanDistance(nodes, nodes[[i]], radius, bipartite)
if (numNodesInManhattanDistance < min) {
labels = c(labels, nodes[[i]][['label']])
ndensity = c(ndensity, NA)
} else {
if(bipartite) {
if(directed) {dir = 2} else {dir = 1}
potential = numNodesInManhattanDistance * (numberNodesWithinManhattanDistance(nodes, nodes[[i]], radius, FALSE) - numNodesInManhattanDistance) * dir
} else {
if(directed) {dir = 1} else {dir = 2}
potential = numNodesInManhattanDistance * (numNodesInManhattanDistance - 1)/dir
}
numEdges = numberEdgesWithinManhattanDistance(nodes, edges, nodes[[i]], radius, FALSE)
nDensity = numEdges / potential
labels = c(labels, nodes[[i]][['label']])
ndensity = c(ndensity, nDensity)
if (nDensity > 1) {stop(paste0('Node', i, ' network density is greater than 1'))}
}
}
heat = data.frame('label' = labels, 'heat' = ndensity)
if(abs(nodes[[1]][['lat']]) <= 180) {
warning("Distance may be calculated in the degree coordinates, which may need to be projected into other distance units")
}
source = c()
target = c()
withinwindow = c()
for (edge in edges) {
source = c(source, edge[['Source']])
target = c(target, edge[['Target']])
if (ManhattanDistance(nodes[[edge[['Source']]]], nodes[[edge[['Target']]]]) < radius) {
withinwindow = c(withinwindow, 1)
} else {
withinwindow = c(withinwindow, 0)
}
}
edgeWithin = data.frame('Source' = source, 'Target' = target, 'WithinWindow' = withinwindow)
return(list(heat, edgeWithin))
}
NDScanMatrix = function(nodes, edges, thres, matrix, min=3, directed=FALSE, bipartite=FALSE) {
if(!inherits(nodes, "list") | !inherits(edges, "list")) {
stop('nodes or edges arguments only intake a list of lists. Please use processNode or processEdge functions to convert R dataframe to a list of lists')
}
if(!inherits(matrix, "matrix")) {
stop('Your matrix input is not recognized as a matrix in R. Please check R matrix formats and make sure you have row and column names for the matrix.')
}
if(!is.null(nodes[[1]][['bipartite']]) & !bipartite) {
stop('Your data has a bipartite column, but your bipartite argument is set to FALSE. Please set your bipartite argument to TRUE')
}
labels = c()
ndensity = c()
if(bipartite) {
if (is.null(nodes[[1]][['bipartite']])) {
stop('Node bipartite value is not available. Please check if node table contains a bipartite column and if the name of the bipartite column is provided in the processNode function')}
#sort so that bipartite == 1 is on top.
nodes = nodes[order(-sapply(nodes, function(x) x[['bipartite']]))]
stop = length(Filter(function(x) all((x <- x$bipartite == 1)), nodes))
#calculate the number of nodes with bipartite == 1
bipartite_num = sum(as.numeric(unlist(nodes)[grepl(pattern='bipartite', names(unlist(nodes)))]))
bipartite_trans_matrix = matrix
#assign node pairs in the same set with values of 0
bipartite_trans_matrix[1:bipartite_num, 1:bipartite_num] <- NA
bipartite_trans_matrix[(bipartite_num+1):length(nodes), (bipartite_num+1):length(nodes)] <- NA
} else {
stop = length(nodes)
}
for (i in seq(1, stop)) {
if(bipartite){
NodesInMatrix = NodesWithinMatrixThres(nodes[[i]][['label']], thres, bipartite_trans_matrix)
} else {
NodesInMatrix = NodesWithinMatrixThres(nodes[[i]][['label']], thres, matrix)
}
numNodesInMatrix = length(NodesInMatrix) + 1 #adding self node
if (numNodesInMatrix < min) {
labels = c(labels, nodes[[i]][['label']])
ndensity = c(ndensity, NA)
} else {
if(bipartite) {
if(directed) {dir = 2} else {dir = 1}
numNodesInMatrixBothSets = length(NodesWithinMatrixThres(nodes[[i]][['label']], thres, matrix))
potential = numNodesInMatrix * (numNodesInMatrixBothSets - numNodesInMatrix) * dir
} else {
if(directed) {dir = 1} else {dir = 2}
potential = numNodesInMatrix * (numNodesInMatrix - 1)/dir
}
numEdges = getNumEdgesInMatrix(nodes[[i]][['label']], names(NodesInMatrix), edges, FALSE)
nDensity = numEdges / potential
labels = c(labels, nodes[[i]][['label']])
ndensity = c(ndensity, nDensity)
if (nDensity > 1) {stop(paste0('Node', i, ' network density is greater than 1'))}
}
}
heat = data.frame('label' = labels, 'heat' = ndensity)
if(abs(nodes[[1]][['lat']]) <= 180) {
warning("Distance may be calculated in the degree coordinates, which may need to be projected into other distance units")
}
source = c()
target = c()
withinwindow = c()
for (edge in edges) {
source = c(source, edge[['Source']])
target = c(target, edge[['Target']])
if(bipartite) {
nameWithinMatrix=names(NodesWithinMatrixThres(edge[['Source']], thres, bipartite_trans_matrix))
} else {
nameWithinMatrix=names(NodesWithinMatrixThres(edge[['Source']], thres, matrix))
}
if (edge[['Target']] %in% nameWithinMatrix) {
withinwindow = c(withinwindow, 1)
} else {
withinwindow = c(withinwindow, 0)
}
}
edgeWithin = data.frame('Source' = source, 'Target' = target, 'WithinWindow' = withinwindow)
return(list(heat, edgeWithin))
}
library(SSNtools)
data(NYCMafiaNodes)
data(NYCMafiaEdges)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
library(SSNtools)
library(tidyverse)
data(NYCMafiaNodes)
data(NYCMafiaEdges)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
edgeWithin = edgeScanManhattan(nodes, edges, 3219)[[2]]
# run osmnx in Python and get the walking distance
dist = read.csv('/Users/xiaofanliang/Dropbox (GaTech)/GT_Research/Edge_Scan/OSM_DistanceMatrix/EdgeScanMatrix_OSMdistance.csv')
edgeWithin2 = edgeWithin %>% left_join(dist, by=c('Source' = 'Source', 'Target' = 'Target'), copy=FALSE) %>%
select(c(Source, Target, Distance_m))
library(igraph)
#create adjacency matrix from edge list. This is a full matrix.
g = graph_from_data_frame(edgeWithin2 %>%
mutate(Distance_m = ifelse(Distance_m == 0, 0.001, Distance_m )), directed=FALSE, vertices=NYCMafiaNodes)
mat = as_adjacency_matrix(g, sparse=F, attr="Distance_m") #fill empty sell with zeros
mat[mat==0]<-NA
NodesWithinMatrixThres(nodes[[1]][['label']], 2414, mat)
getNumEdgesInMatrix(nodes[[1]][['label']], names(NodesWithinMatrixThres(nodes[[1]][['label']], 2414, mat)), edges, FALSE)
