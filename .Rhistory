mat = matrix(NA, nrow(el), nrow(el))
mat[el[,1:2]] <- as.numeric(el[,3])
mat[el[,1:2]]
el[,1:2]
mat[el[,1:2]]
library(igraph)
g = graph_from_data_frame(edgeWithin2, directed=FALSE)
as.matrix(g, matrix.type=c('adjacency'))
as.matrix(g, matrix.type=c('adjacency'),sparse=FALSE, attr="Distance_m")
as_adjacency_matrix(g, sparse=FALSE, attr="Distance_m")
as_adjacency_matrix(g, sparse=FALSE, attr="Distance_m")[1:10][1:10]
as_adjacency_matrix(g, sparse=FALSE, attr="Distance_m")
as_adjacency_matrix(g, sparse=T, attr="Distance_m")
as_adjacency_matrix(g, sparse=F, attr="Distance_m")
mat = as_adjacency_matrix(g, sparse=F, attr="Distance_m")
edgeWithin2 = edgeWithin %>% left_join(dist, by=c('Source' = 'Source', 'Target' = 'Target'), copy=FALSE) %>%
select(c(Source, Target, Distance_m))
View(edgeWithin2)
mat['SALERNO-ANTHONY', ]
mat <- formatSpMatrix(mat, zero.print = "NA")
mat = as_adjacency_matrix(g, sparse=T, attr="Distance_m")
mat <- formatSpMatrix(mat, zero.print = "NA")
mat
mat = as_adjacency_matrix(g, sparse=F, attr="Distance_m")
mat <- formatSpMatrix(mat, zero.print = "NA")
mat = as_adjacency_matrix(g, sparse=F, attr="Distance_m")
mat
g = graph_from_data_frame(edgeWithin2 %>% drop_na(Distance_m), directed=FALSE)
mat = as_adjacency_matrix(g, sparse=F, attr="Distance_m")
mat
mat['SALERNO-ANTHONY', ]
mat['SMURRA-GEORGE', ]
g = graph_from_data_frame(edgeWithin2 %>% drop_na(Distance_m) %>% mutate(Distance_m = ifelse(Distance_m == 0, 0.001, Distance_m )), directed=FALSE)
mat = as_adjacency_matrix(g, sparse=F, attr="Distance_m")
mat['LEO-ARTHUR', ]
mat[mat==0]<-NA
mat['LEO-ARTHUR', ]
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
temp = edgeScanMatrix(nodes, edges, 2414, min=3)
temp = edgeScanMatrix(nodes, edges, 2414, mat, min=3)
mat[1:10]
mat[1:10,][,1:10]
edgeWithin2 %>% drop_na(Distance_m) %>%
mutate(Distance_m = ifelse(Distance_m == 0, 0.001, Distance_m ) %>% nrow()
edgeWithin2 %>% drop_na(Distance_m) %>%
mutate(Distance_m = ifelse(Distance_m == 0, 0.001, Distance_m )) %>% nrow()
edgeWithin2 %>% drop_na(Distance_m) %>%
mutate(Distance_m = ifelse(Distance_m == 0, 0.001, Distance_m )) %>% nrow()
mat = as_adjacency_matrix(g, sparse=T, attr="Distance_m") #fill empty sell with zeros
mat = as_adjacency_matrix(g, sparse=F, attr="Distance_m") #fill empty sell with zeros
g = graph_from_data_frame(edgeWithin2 %>% #drop_na(Distance_m) %>%
mutate(Distance_m = ifelse(Distance_m == 0, 0.001, Distance_m )), directed=FALSE)
mat = as_adjacency_matrix(g, sparse=F, attr="Distance_m") #fill empty sell with zeros
g = graph_from_data_frame(edgeWithin2 %>% #drop_na(Distance_m) %>%
mutate(Distance_m = ifelse(Distance_m == 0, 0.001, Distance_m )), directed=FALSE, vertices=NYCMafiaNodes)
mat = as_adjacency_matrix(g, sparse=F, attr="Distance_m") #fill empty sell with zeros
mat[mat==0]<-NA
mat[1:10,][,1:10]
temp = edgeScanMatrix(nodes, edges, 2414, mat, min=3)
heat = temp[[1]]
View(heat)
temp2 = NDScanMatrix(nodes, edges, 2414, mat, min=3)
heat2 = temp2[[1]]
View(heat2)
heat = heat %>% left_join(NYCMafiaNodes, copy=FALSE) %>% st_as_sf(coords=c('LonX', 'LatY'), crs=32118)
tmap_mode('view')
tmap_mode('view')
tm_shape(heat) +
tm_symbols(col='heat', size=0.1, style='fixed', legend.col.show = FALSE, palette = c('#FBD977', '#F78D3D', '#E3211B', '#800F26'))
tm_shape(heat) +
tm_symbols(col='heat', size=0.1, legend.col.show = FALSE, palette = c('#FBD977', '#F78D3D', '#E3211B', '#800F26'))
View(heat)
heat2 = heat2 %>% left_join(NYCMafiaNodes, copy=FALSE) %>% st_as_sf(coords=c('LonX', 'LatY'), crs=32118)
tmap_mode('view')
tm_shape(heat2) +
tm_symbols(col='heat', size=0.1, legend.col.show = FALSE, palette = c('#FBD977', '#F78D3D', '#E3211B', '#800F26'))
NodesWithinMatrixThres('DIPALERMO-JOSEPH', 2414, mat)
#return a matrix. If the network is bipartite, assign value 0 to pairs that are not supposed to have connections, i.e., in the same category
NodesWithinMatrixThres = function(node_label, thres, matrix){
#return matrix of nodes with only node pairs within distance threshold, excluding same nodes.
return(matrix[node_label,][matrix[node_label,]<thres & !is.na(m[node_label,])]) #matrix[node_label,]!=0
}
NodesWithinMatrixThres('DIPALERMO-JOSEPH', 2414, mat)
!is.na(mat['DIPALERMO-JOSEPH',])
mat['DIPALERMO-JOSEPH',][mat['DIPALERMO-JOSEPH',]<2414 & !is.na(mat['DIPALERMO-JOSEPH',])]
#return a matrix. If the network is bipartite, assign value 0 to pairs that are not supposed to have connections, i.e., in the same category
NodesWithinMatrixThres = function(node_label, thres, matrix){
#return matrix of nodes with only node pairs within distance threshold, excluding same nodes.
return(matrix[node_label,][matrix[node_label,]<thres & !is.na(m[node_label,])]) #matrix[node_label,]!=0
}
NodesWithinMatrixThres('DIPALERMO-JOSEPH', 2414, mat)
#return a matrix. If the network is bipartite, assign value 0 to pairs that are not supposed to have connections, i.e., in the same category
NodesWithinMatrixThres2 = function(node_label, thres, matrix){
#return matrix of nodes with only node pairs within distance threshold, excluding same nodes.
return(matrix[node_label,][matrix[node_label,]<thres & !is.na(m[node_label,])]) #matrix[node_label,]!=0
}
length(NodesWithinMatrixThres2('DIPALERMO-JOSEPH', 2414, mat))
#return a matrix. If the network is bipartite, assign value 0 to pairs that are not supposed to have connections, i.e., in the same category
NodesWithinMatrixThres2 = function(node_label, thres, matrix){
#return matrix of nodes with only node pairs within distance threshold, excluding same nodes.
return(matrix[node_label,][matrix[node_label,]<thres & !is.na(matrix[node_label,])]) #matrix[node_label,]!=0
}
NodesWithinMatrixThres2('DIPALERMO-JOSEPH', 2414, mat)
#return a matrix. If the network is bipartite, assign value 0 to pairs that are not supposed to have connections, i.e., in the same category
NodesWithinMatrixThres = function(node_label, thres, matrix){
#return matrix of nodes with only node pairs within distance threshold, excluding same nodes.
return(matrix[node_label,][matrix[node_label,]<thres & !is.na(matrix[node_label,])]) #matrix[node_label,]!=0
}
g = graph_from_data_frame(edgeWithin2 %>% #drop_na(Distance_m) %>%
mutate(Distance_m = ifelse(Distance_m == 0, 0.001, Distance_m )), directed=FALSE, vertices=NYCMafiaNodes)
mat = as_adjacency_matrix(g, sparse=F, attr="Distance_m") #fill empty sell with zeros
mat[mat==0]<-NA
temp = edgeScanMatrix(nodes, edges, 2414, mat, min=3)
heat = temp[[1]]
#return a matrix. If the network is bipartite, assign value 0 to pairs that are not supposed to have connections, i.e., in the same category
NodesWithinMatrixThres = function(node_label, thres, matrix){
#return matrix of nodes with only node pairs within distance threshold, excluding same nodes.
return(matrix[node_label,][matrix[node_label,]<thres & !is.na(matrix[node_label,])]) #matrix[node_label,]!=0
}
g = graph_from_data_frame(edgeWithin2 %>% #drop_na(Distance_m) %>%
mutate(Distance_m = ifelse(Distance_m == 0, 0.001, Distance_m )), directed=FALSE, vertices=NYCMafiaNodes)
mat = as_adjacency_matrix(g, sparse=F, attr="Distance_m") #fill empty sell with zeros
mat[mat==0]<-NA
temp = edgeScanMatrix(nodes, edges, 2414, mat, min=3)
heat = temp[[1]]
NDScanMatrix = function(nodes, edges, thres, matrix, min=3, directed=FALSE, bipartite=FALSE) {
if(!inherits(nodes, "list") | !inherits(edges, "list")) {
stop('nodes or edges arguments only intake a list of lists. Please use processNode or processEdge functions to convert R dataframe to a list of lists')
}
if(!inherits(matrix, "matrix")) {
stop('Your matrix input is not recognized as a matrix in R. Please check R matrix formats and make sure you have row and column names for the matrix.')
}
if(!is.null(nodes[[1]][['bipartite']]) & !bipartite) {
stop('Your data has a bipartite column, but your bipartite argument is set to FALSE. Please set your bipartite argument to TRUE')
}
labels = c()
ndensity = c()
if(bipartite) {
if (is.null(nodes[[1]][['bipartite']])) {
stop('Node bipartite value is not available. Please check if node table contains a bipartite column and if the name of the bipartite column is provided in the processNode function')}
#sort so that bipartite == 1 is on top.
nodes = nodes[order(-sapply(nodes, function(x) x[['bipartite']]))]
stop = length(Filter(function(x) all((x <- x$bipartite == 1)), nodes))
#calculate the number of nodes with bipartite == 1
bipartite_num = sum(as.numeric(unlist(nodes)[grepl(pattern='bipartite', names(unlist(nodes)))]))
bipartite_trans_matrix = matrix
#assign node pairs in the same set with values of 0
bipartite_trans_matrix[1:bipartite_num, 1:bipartite_num] <- NA
bipartite_trans_matrix[(bipartite_num+1):length(nodes), (bipartite_num+1):length(nodes)] <- NA
} else {
stop = length(nodes)
}
for (i in seq(1, stop)) {
if(bipartite){
NodesInMatrix = NodesWithinMatrixThres(nodes[[i]][['label']], thres, bipartite_trans_matrix)
} else {
NodesInMatrix = NodesWithinMatrixThres(nodes[[i]][['label']], thres, matrix)
}
numNodesInMatrix = length(NodesInMatrix)
if (numNodesInMatrix < min) {
labels = c(labels, nodes[[i]][['label']])
ndensity = c(ndensity, NA)
} else {
if(bipartite) {
if(directed) {dir = 2} else {dir = 1}
numNodesInMatrixBothSets = length(NodesWithinMatrixThres(nodes[[i]][['label']], thres, matrix))
potential = numNodesInMatrix * (numNodesInMatrixBothSets - numNodesInMatrix) * dir
} else {
if(directed) {dir = 1} else {dir = 2}
potential = numNodesInMatrix * (numNodesInMatrix - 1)/dir
}
numEdges = getNumEdgesInMatrix(nodes[[i]][['label']], names(NodesInMatrix), edges, FALSE)
nDensity = numEdges / potential
labels = c(labels, nodes[[i]][['label']])
ndensity = c(ndensity, nDensity)
if (nDensity > 1) {stop(paste0('Node', i, ' network density is greater than 1'))}
}
}
heat = data.frame('label' = labels, 'heat' = ndensity)
if(abs(nodes[[1]][['lat']]) <= 180) {
warning("Distance may be calculated in the degree coordinates, which may need to be projected into other distance units")
}
source = c()
target = c()
withinwindow = c()
for (edge in edges) {
source = c(source, edge[['Source']])
target = c(target, edge[['Target']])
if(bipartite) {
nameWithinMatrix=names(NodesWithinMatrixThres(edge[['Source']], thres, bipartite_trans_matrix))
} else {
nameWithinMatrix=names(NodesWithinMatrixThres(edge[['Source']], thres, matrix))
}
if (edge[['Target']] %in% nameWithinMatrix) {
withinwindow = c(withinwindow, 1)
} else {
withinwindow = c(withinwindow, 0)
}
}
edgeWithin = data.frame('Source' = source, 'Target' = target, 'WithinWindow' = withinwindow)
return(list(heat, edgeWithin))
}
edgeScanMatrix = function(nodes, edges, thres, matrix, min=3, weighted=FALSE, bipartite=FALSE) {
if(!inherits(nodes, "list") | !inherits(edges, "list")) {
stop('nodes or edges arguments only intake a list of lists. Please use processNode or processEdge functions to convert R dataframe to a list of lists')
}
if(!inherits(matrix, "matrix")) {
stop('Your matrix input is not recognized as a matrix in R. Please check R matrix formats and make sure you have row and column names for the matrix.')
}
if(!is.null(nodes[[1]][['bipartite']]) & !bipartite) {
stop('Your data has a bipartite column, but your bipartite argument is set to FALSE. Please set your bipartite argument to TRUE')
}
labels = c()
numedges = c()
if(bipartite) {
if (is.null(nodes[[1]][['bipartite']])) {
stop('Node bipartite value is not available. Please check if node table contains a bipartite column and if the name of the bipartite column is provided in the processNode function')}
#sort so that bipartite == 1 is on top.
nodes = nodes[order(-sapply(nodes, function(x) x[['bipartite']]))]
stop = length(Filter(function(x) all((x <- x$bipartite == 1)), nodes))
#calculate the number of nodes with bipartite == 1
bipartite_num = sum(as.numeric(unlist(nodes)[grepl(pattern='bipartite', names(unlist(nodes)))]))
bipartite_trans_matrix = matrix
#assign node pairs in the same set with values of 0
bipartite_trans_matrix[1:bipartite_num, 1:bipartite_num] <- NA
bipartite_trans_matrix[(bipartite_num+1):length(nodes), (bipartite_num+1):length(nodes)] <- NA
} else {
stop = length(nodes)
}
for (i in seq(1, stop)) {
if(bipartite){
NodesInMatrix = NodesWithinMatrixThres(nodes[[i]][['label']], thres, bipartite_trans_matrix)
} else {
NodesInMatrix = NodesWithinMatrixThres(nodes[[i]][['label']], thres, matrix)
}
numNodesInMatrix = length(NodesInMatrix)
if (numNodesInMatrix < min) {
labels = c(labels, nodes[[i]][['label']])
numedges = c(numedges, NA)
} else {
numEdges = getNumEdgesInMatrix(nodes[[i]][['label']], names(NodesInMatrix), edges, weighted)
labels = c(labels, nodes[[i]][['label']])
numedges = c(numedges, numEdges)
}
}
heat = data.frame('label' = labels, 'heat' = numedges)
if(abs(nodes[[1]][['lat']]) <= 180) {
warning("Distance may be calculated in the degree coordinates, which may need to be projected into other distance units")
}
source = c()
target = c()
weight = c()
withinwindow = c()
for (edge in edges) {
source = c(source, edge[['Source']])
target = c(target, edge[['Target']])
if(weighted) {weight = c(weight, edge[['Weight']])}
if (edge[['Target']] %in% names(NodesWithinMatrixThres(edge[['Source']], thres, matrix))) {
withinwindow = c(withinwindow, 1)
} else {
withinwindow = c(withinwindow, 0)
}
}
if(weighted) {
edgeWithin = data.frame('Source' = source, 'Target' = target, 'Weight' = weight, 'WithinWindow' = withinwindow)
} else {
edgeWithin = data.frame('Source' = source, 'Target' = target, 'WithinWindow' = withinwindow)
}
return(list(heat, edgeWithin))
}
NodesWithinMatrixThres('DIPALERMO-JOSEPH', 2414, mat)
getNumEdgesInMatrix('DIPALERMO-JOSEPH', names(NodesWithinMatrixThres('DIPALERMO-JOSEPH', 2414, mat)), edges, FALSE)
#create a fake matrix for non-bipartite network
n = 298
m = matrix(1:(n*n), ncol=n)
#create a fake matrix for non-bipartite network
n = 298
m = matrix(1:(n*n), ncol=n)
colnames(m) = NYCMafiaNodes$label[1:n]
rownames(m) = NYCMafiaNodes$label[1:n]
diag(m) <- NA
m[lower.tri(m)] = t(m)[lower.tri(m)]
nodes <- processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges <- processEdge(NYCMafiaEdges, 'Source', 'Target')
data("NYCMafiaNodes")
data("NYCMafiaEdges")
result7 = edgeScanMatrix(nodes, edges, 100, matrix)[[1]]
edgeScanMatrix = function(nodes, edges, thres, matrix, min=3, weighted=FALSE, bipartite=FALSE) {
if(!inherits(nodes, "list") | !inherits(edges, "list")) {
stop('nodes or edges arguments only intake a list of lists. Please use processNode or processEdge functions to convert R dataframe to a list of lists')
}
if(!inherits(matrix, "matrix")) {
stop('Your matrix input is not recognized as a matrix in R. Please check R matrix formats and make sure you have row and column names for the matrix.')
}
if(!is.null(nodes[[1]][['bipartite']]) & !bipartite) {
stop('Your data has a bipartite column, but your bipartite argument is set to FALSE. Please set your bipartite argument to TRUE')
}
labels = c()
numedges = c()
if(bipartite) {
if (is.null(nodes[[1]][['bipartite']])) {
stop('Node bipartite value is not available. Please check if node table contains a bipartite column and if the name of the bipartite column is provided in the processNode function')}
#sort so that bipartite == 1 is on top.
nodes = nodes[order(-sapply(nodes, function(x) x[['bipartite']]))]
stop = length(Filter(function(x) all((x <- x$bipartite == 1)), nodes))
#calculate the number of nodes with bipartite == 1
bipartite_num = sum(as.numeric(unlist(nodes)[grepl(pattern='bipartite', names(unlist(nodes)))]))
bipartite_trans_matrix = matrix
#assign node pairs in the same set with values of 0
bipartite_trans_matrix[1:bipartite_num, 1:bipartite_num] <- NA
bipartite_trans_matrix[(bipartite_num+1):length(nodes), (bipartite_num+1):length(nodes)] <- NA
} else {
stop = length(nodes)
}
for (i in seq(1, stop)) {
if(bipartite){
NodesInMatrix = NodesWithinMatrixThres(nodes[[i]][['label']], thres, bipartite_trans_matrix)
} else {
NodesInMatrix = NodesWithinMatrixThres(nodes[[i]][['label']], thres, matrix)
}
numNodesInMatrix = length(NodesInMatrix)
if (numNodesInMatrix < min) {
labels = c(labels, nodes[[i]][['label']])
numedges = c(numedges, NA)
} else {
numEdges = getNumEdgesInMatrix(nodes[[i]][['label']], names(NodesInMatrix), edges, weighted)
labels = c(labels, nodes[[i]][['label']])
numedges = c(numedges, numEdges)
}
}
heat = data.frame('label' = labels, 'heat' = numedges)
if(abs(nodes[[1]][['lat']]) <= 180) {
warning("Distance may be calculated in the degree coordinates, which may need to be projected into other distance units")
}
source = c()
target = c()
weight = c()
withinwindow = c()
for (edge in edges) {
source = c(source, edge[['Source']])
target = c(target, edge[['Target']])
if(weighted) {weight = c(weight, edge[['Weight']])}
if (edge[['Target']] %in% names(NodesWithinMatrixThres(edge[['Source']], thres, matrix))) {
withinwindow = c(withinwindow, 1)
} else {
withinwindow = c(withinwindow, 0)
}
}
if(weighted) {
edgeWithin = data.frame('Source' = source, 'Target' = target, 'Weight' = weight, 'WithinWindow' = withinwindow)
} else {
edgeWithin = data.frame('Source' = source, 'Target' = target, 'WithinWindow' = withinwindow)
}
return(list(heat, edgeWithin))
}
result7 = edgeScanMatrix(nodes, edges, 100, matrix)[[1]]
result7 = edgeScanMatrix(nodes, edges, 100, m)[[1]]
#return a matrix. If the network is bipartite, assign value 0 to pairs that are not supposed to have connections, i.e., in the same category
NodesWithinMatrixThres = function(node_label, thres, matrix){
#return matrix of nodes with only node pairs within distance threshold, excluding same nodes.
return(matrix[node_label,][matrix[node_label,]<thres & !is.na(matrix[node_label,])]) #matrix[node_label,]!=0
}
getNumEdgesInMatrix = function(node_label, names, edges, weighted) {
retVal = 0
for (edge in edges) {
if(edge[['Source']] %in% c(names, node_label) & edge[['Target']] %in% c(names, node_label)) {
if(weighted) {
if(is.null(edge[['Weight']])) {
stop('Edge weight is not available. Please check if edge table contains a weight column and if the name of the weight column is provided in the processEdge function')
} else {retVal = retVal + edge[['Weight']]}
} else {
retVal = retVal + 1
}
}
}
return (retVal)
}
result7 = edgeScanMatrix(nodes, edges, 100, m)[[1]]
View(result7)
nodes[[1]]
m['AMAROSA-ALEXANDER', ]
result7 = edgeScanMatrix(nodes, edges, 1000, m)[[1]]
result7 = edgeScanMatrix(nodes, edges, 10000, m)[[1]]
nodes <- processNode(POINodes, 'label', 'LonX', 'LatY', 'Bipartite')
edges <- processEdge(POIEdges, 'Source', 'Target', 'Weight')
#create a fake matrix for bipartite network
n = 1356
m = matrix(1:(n*n), ncol=n)
colnames(m) = POINodes$label[1:n]
rownames(m) = POINodes$label[1:n]
diag(m) <- NA
m[lower.tri(m)] = t(m)[lower.tri(m)]
result7 <- edgeScanMatrix(nodes, edges, 100000, m, weighted=TRUE, bipartite=TRUE)[[1]]
View(result7)
nodes[[1]]
#create a fake matrix for bipartite network
n = 1356
m = matrix(sample.int(100, n*n, replace=TRUE), ncol=n)
colnames(m) = POINodes$label[1:n]
rownames(m) = POINodes$label[1:n]
diag(m) <- NA
m[lower.tri(m)] = t(m)[lower.tri(m)]
result7 <- edgeScanMatrix(nodes, edges, 5, m, weighted=TRUE, bipartite=TRUE)[[1]]
nodes <- processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges <- processEdge(NYCMafiaEdges, 'Source', 'Target')
#create a fake matrix for non-bipartite network
n = 298
m = matrix(sample.int(10, n*n, replace=TRUE), ncol=n)
colnames(m) = NYCMafiaNodes$label[1:n]
rownames(m) = NYCMafiaNodes$label[1:n]
diag(m) <- NA
m[lower.tri(m)] = t(m)[lower.tri(m)]
result7 = edgeScanMatrix(nodes, edges, 10000, m)[[1]]
result7 = edgeScanMatrix(nodes, edges, 5, m)[[1]]
result8 = NDScanMatrix(nodes, edges, 5, m)[[1]]
NDScanMatrix = function(nodes, edges, thres, matrix, min=3, directed=FALSE, bipartite=FALSE) {
if(!inherits(nodes, "list") | !inherits(edges, "list")) {
stop('nodes or edges arguments only intake a list of lists. Please use processNode or processEdge functions to convert R dataframe to a list of lists')
}
if(!inherits(matrix, "matrix")) {
stop('Your matrix input is not recognized as a matrix in R. Please check R matrix formats and make sure you have row and column names for the matrix.')
}
if(!is.null(nodes[[1]][['bipartite']]) & !bipartite) {
stop('Your data has a bipartite column, but your bipartite argument is set to FALSE. Please set your bipartite argument to TRUE')
}
labels = c()
ndensity = c()
if(bipartite) {
if (is.null(nodes[[1]][['bipartite']])) {
stop('Node bipartite value is not available. Please check if node table contains a bipartite column and if the name of the bipartite column is provided in the processNode function')}
#sort so that bipartite == 1 is on top.
nodes = nodes[order(-sapply(nodes, function(x) x[['bipartite']]))]
stop = length(Filter(function(x) all((x <- x$bipartite == 1)), nodes))
#calculate the number of nodes with bipartite == 1
bipartite_num = sum(as.numeric(unlist(nodes)[grepl(pattern='bipartite', names(unlist(nodes)))]))
bipartite_trans_matrix = matrix
#assign node pairs in the same set with values of 0
bipartite_trans_matrix[1:bipartite_num, 1:bipartite_num] <- NA
bipartite_trans_matrix[(bipartite_num+1):length(nodes), (bipartite_num+1):length(nodes)] <- NA
} else {
stop = length(nodes)
}
for (i in seq(1, stop)) {
if(bipartite){
NodesInMatrix = NodesWithinMatrixThres(nodes[[i]][['label']], thres, bipartite_trans_matrix)
} else {
NodesInMatrix = NodesWithinMatrixThres(nodes[[i]][['label']], thres, matrix)
}
numNodesInMatrix = length(NodesInMatrix)
if (numNodesInMatrix < min) {
labels = c(labels, nodes[[i]][['label']])
ndensity = c(ndensity, NA)
} else {
if(bipartite) {
if(directed) {dir = 2} else {dir = 1}
numNodesInMatrixBothSets = length(NodesWithinMatrixThres(nodes[[i]][['label']], thres, matrix))
potential = numNodesInMatrix * (numNodesInMatrixBothSets - numNodesInMatrix) * dir
} else {
if(directed) {dir = 1} else {dir = 2}
potential = numNodesInMatrix * (numNodesInMatrix - 1)/dir
}
numEdges = getNumEdgesInMatrix(nodes[[i]][['label']], names(NodesInMatrix), edges, FALSE)
nDensity = numEdges / potential
labels = c(labels, nodes[[i]][['label']])
ndensity = c(ndensity, nDensity)
if (nDensity > 1) {stop(paste0('Node', i, ' network density is greater than 1'))}
}
}
heat = data.frame('label' = labels, 'heat' = ndensity)
if(abs(nodes[[1]][['lat']]) <= 180) {
warning("Distance may be calculated in the degree coordinates, which may need to be projected into other distance units")
}
source = c()
target = c()
withinwindow = c()
for (edge in edges) {
source = c(source, edge[['Source']])
target = c(target, edge[['Target']])
if(bipartite) {
nameWithinMatrix=names(NodesWithinMatrixThres(edge[['Source']], thres, bipartite_trans_matrix))
} else {
nameWithinMatrix=names(NodesWithinMatrixThres(edge[['Source']], thres, matrix))
}
if (edge[['Target']] %in% nameWithinMatrix) {
withinwindow = c(withinwindow, 1)
} else {
withinwindow = c(withinwindow, 0)
}
}
edgeWithin = data.frame('Source' = source, 'Target' = target, 'WithinWindow' = withinwindow)
return(list(heat, edgeWithin))
}
result8 = NDScanMatrix(nodes, edges, 5, m)[[1]]
View(result8)
library(SSNtools)
library(SSNtools)
#create a fake matrix for non-bipartite network
n = 298
m = matrix(sample.int(10, n*n, replace=TRUE), ncol=n)
colnames(m) = NYCMafiaNodes$label[1:n]
rownames(m) = NYCMafiaNodes$label[1:n]
diag(m) <- NA
m[lower.tri(m)] = t(m)[lower.tri(m)]
data("NYCMafiaNodes")
data("NYCMafiaEdges")
nodes <- processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges <- processEdge(NYCMafiaEdges, 'Source', 'Target')
result7 = edgeScanMatrix(nodes, edges, 5, m)[[1]]
View(result7)
result7 %>% nrow()
length(nodes)
