library(SSNHotSpot)
nodes = processNode(example_nodes, 'label', 'lon', 'lat')
edges = processNode(example_edges, 'Source', 'Target')
edges = processEdge(example_edges, 'Source', 'Target')
kk = edgeScanRadius(example_nodes, edges, 500)
!is.list(example_nodes) } !is.list(edges)
!is.list(example_nodes) | !is.list(edges)
!is.list(example_nodes)
kk = example_nodes
View(kk)
is.list(example_nodes)
is.list(nodes)
library(SSNHotSpot)
nodes = processNode(example_nodes, 'label', 'lon', 'lat')
edges = processNode(example_edges, 'Source', 'Target')
edges = processEdge(example_edges, 'Source', 'Target')
kk = edgeScanRadius(example_nodes, edges, 500)
!inherits(nodes, "list")
inherits(nodes, "list")
inherits(example_nodes, "list")
if(FALSE | TRUE) {print('hi')}
!inherits(example_nodes, "list")
if(!inherits(example_nodes, "list") | !inherits(edges, "list")){print('hi')}
kk = edgeScanRadius(example_nodes, edges, 500)
kk = edgeScanRadius(example_nodes, edges, 500)
devtools::check()
library(SSNHotSpot)
kk = edgeScanRadius(example_nodes, example_edges, 500)
library(SSNHotSpot)
kk = edgeScanRadius(example_nodes, example_edges, 500)
library(SSNHotSpot)
install.packages('SSNHotSpot')
install.packages("SSNHotSpot")
rmarkdown::render("README.Rmd")
devtools::install_github("friendlycities-gatech/SSNHotSpot")
devtools::install_github("friendlycities-gatech/SSNHotSpot")
devtools::install_github('walkerke/tigris')
devtools::install_github("friendlycities-gatech/SSNHotSpot")
options(download.file.method = "libcurl")
devtools::install_github("friendlycities-gatech/SSNHotSpot")
library(SSNHotSpot)
devtools::check()
library(SSNtools)
rmarkdown::render("README.Rmd")
rmarkdown::render("README.Rmd")
rmarkdown::render("README.Rmd")
rmarkdown::render("README.Rmd")
devtools::check()
devtools::check()
rmarkdown::render("README.Rmd")
output: rmarkdown::github_document
output: rmarkdown::github_document
rmarkdown::render("README.Rmd")
rmarkdown::render("README.Rmd")
output: rmarkdown::github_document
output: rmarkdown::github_document
rmarkdown::render("README.Rmd")
library(SSNtools)
library(SSNtools)
nrow(MafiaNodes)
devtools::check()
devtools::check()
library(SSNtools)
nrow(MafiaNodes)
nrow(NYCMafiaNodes)
devtools::check()
if (!require("pacman")) install.packages("pacman")
pacman::p_load(usethis, here)
#------Each node is stored a named list ------#
#------nodes is a list of named list ---------#
#=-----The process returns a list of named lists with the named key as label
NYCMafiaNodes <- read.csv(here::here("data-raw", "Filtered_MafiaNodes.csv"))
NYCMafiaEdges <- read.csv(here::here("data-raw", "Filtered_MafiaEdges.csv"))
usethis::use_data(NYCMafiaNodes, overwrite = TRUE)
usethis::use_data(NYCMafiaEdges, overwrite = TRUE)
MafiaNodes <- read.csv(here::here("data-raw", "MafiaNodes.csv"))
MafiaEdges <- read.csv(here::here("data-raw", "MafiaEdges.csv"))
usethis::use_data(MafiaNodes, overwrite = TRUE)
usethis::use_data(MafiaEdges, overwrite = TRUE)
devtools::check()
devtools::check()
devtools::check()
library(SSNtools)
nrow(MafiaNodes)
rmarkdown::render("README.Rmd")
rmarkdown::render("README.Rmd")
# load required packages ----
if (!require("pacman")) install.packages("pacman")
pacman::p_load(usethis, here)
#------Each node is stored a named list ------#
#------nodes is a list of named list ---------#
#=-----The process returns a list of named lists with the named key as label
NYCMafiaNodes <- read.csv(here::here("data-raw", "Filtered_MafiaNodes.csv"))
NYCMafiaEdges <- read.csv(here::here("data-raw", "Filtered_MafiaEdges.csv"))
usethis::use_data(NYCMafiaNodes, overwrite = TRUE)
usethis::use_data(NYCMafiaEdges, overwrite = TRUE)
MafiaNodes <- read.csv(here::here("data-raw", "MafiaNodes.csv"))
MafiaEdges <- read.csv(here::here("data-raw", "MafiaEdges.csv"))
usethis::use_data(MafiaNodes, overwrite = TRUE)
usethis::use_data(MafiaEdges, overwrite = TRUE)
library(SSNtools)
devtools::test()
install.packages("SSNtools")
library(SSNtools)
library(igraph)
library(tidyverse)
library(igraph)
library(tmap)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
MafiaSpatial = NYCMafiaNodes %>%
st_as_sf(coords=c("LonX", "LatY"), crs = 4326)
library(sf)
MafiaSpatial = NYCMafiaNodes %>%
st_as_sf(coords=c("LonX", "LatY"), crs = 4326)
# load required packages ----
if (!require("pacman")) install.packages("pacman")
pacman::p_load(usethis, here)
#------Each node is stored a named list ------#
#------nodes is a list of named list ---------#
#=-----The process returns a list of named lists with the named key as label
NYCMafiaNodes <- read.csv(here::here("data-raw", "NYCMafiaNodes.csv"))
NYCMafiaEdges <- read.csv(here::here("data-raw", "NYCMafiaEdges.csv"))
usethis::use_data(NYCMafiaNodes, overwrite = TRUE)
usethis::use_data(NYCMafiaEdges, overwrite = TRUE)
MafiaNodes <- read.csv(here::here("data-raw", "MafiaNodes.csv"))
MafiaEdges <- read.csv(here::here("data-raw", "MafiaEdges.csv"))
usethis::use_data(MafiaNodes, overwrite = TRUE)
usethis::use_data(MafiaEdges, overwrite = TRUE)
c(1,2,3) %in% c(1,2,3,4)
c(1,2,3,4) %in% c(1,2,3)
if(c(1,2,3,4) %in% c(1,2,3)) {print('hello')}
FALSE %in% c(c(1,2,3,4) %in% c(1,2,3))
if (FALSE %in% c(c(1,2,3,4) %in% c(1,2,3))) {print('hello')}
library(SSNtools)
list('a' = c(1,2,3))
kk = list('a' = c(1,2,3))
kk[['a']]
kk[['b']]
is.null(kk[['b']])
library(SSNtools)
nodes = processNode(NYCMafiaNodes, 'NODE', 'LonX', 'LatY')
edges = processEdge(MafiaEdges, 'Source', 'Target')
result = NDScanRadius(nodes, edges, 500)
nodes = processNode(NYCMafiaNodes, 'NODE', 'LonX', 'LatY')
library(SSNtools)
NYCMafiaNodes = NYCMafiaNodes
nodes = processNode(NYCMafiaNodes, 'NODE', 'LonX', 'LatY')
library(SSNtools)
nodes = processNode(NYCMafiaNodes, 'NODE', 'LonX', 'LatY')
print(Null)
print(kk[['b']])
library(SSNtools)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
nodes = processNode(NYCMafiaNodes, 'NODE', 'LonX', 'LatY')
edges = processEdge(MafiaEdges, 'Source', 'Target')
result = NDScanRadius(nodes, edges, 500)
library(SSNtools)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
result = NDScanRadius(nodes, edges, 500)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
library(SSNtools)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
library(SSNtools)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
result = NDScanRadius(nodes, edges, 500)
View(result)
result = NDScanRadius(nodes, edges, 500, min=4)
View(result)
library(SSNtools)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
result = NDScanKNearest(nodes, edges, 10, min=4)
library(SSNtools)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
result = NDScanKNearest(nodes, edges, 10, min=4)
library(SSNtools)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
result = NDScanKNearest(nodes, edges, 10, min=4)
library(SSNtools)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
result = NDScanKNearest(nodes, edges, 10, min=4)
library(SSNtools)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
result = NDScanKNearest(nodes, edges, 10)
result = NDScanManhattan(nodes, edges, 1000, 4)
result = NDScanManhattan(nodes, edges, 1000, min=4)
result = NDScanRadius(nodes, edges, 1000, min=4)
devtools::install_github("friendlycities-gatech/SSNtools")
devtools::install_github("friendlycities-gatech/SSNtools", force=TRUE)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
result = NDScanManhattan(nodes, edges, 1000, 4)
result = NDScanManhattan(nodes, edges, 1000, min=4)
library(SSNtools)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
result = NDScanManhattan(nodes, edges, 1000, 4)
result = NDScanManhattan(nodes, edges, 1000, min=4)
result = NDScanManhattan(nodes, edges, 1000)
result = NDScanManhattan(nodes, edges, 1000, min=3)
library(SSNtools)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
result = NDScanManhattan(nodes, edges, 1000, 4)
library(SSNtools)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
result = NDScanManhattan(nodes, edges, 1000, 4)
NDScanManhattan = function(nodes, edges, distance, min=3) {
if(!inherits(nodes, "list") | !inherits(edges, "list")) {
stop('nodes or edges need to be a list of lists. Please use processNode or processEdge to convert R dataframe to a list of lists')
}
visitedNodes = list()
labels = c()
ndensity = c()
runningNode = nodes[[1]]
while (length(visitedNodes) < length(nodes)) {
numNodesInRadius = numberNodesWithinRadius(nodes, runningNode, distance)
if (numNodesInRadius < min) {
labels = c(labels, runningNode[['label']])
ndensity = c(ndensity, NA)
} else {
numNodesInManhattanDistance = numberNodesWithinManhattanDistance(nodes, runningNode, distance)
edgesInManhattanDistance = getEdgesInManhattanDistance(nodes, edges, runningNode, distance)
#nodesInManhattanDistance = getNodesInManhattanDistance(nodes, runningNode, distance)
potentialEdges = numNodesInManhattanDistance * (numNodesInManhattanDistance - 1) / 2
numEdges = numberEdgesWithinManhattanDistance(nodes, edges, runningNode, distance)
if (numNodesInManhattanDistance < 3) {
labels = c(labels, runningNode[['label']])
ndensity = c(ndensity, 0)
} else {
nDensity = numEdges/potentialEdges
labels = c(labels, runningNode[['label']])
ndensity = c(ndensity, nDensity)
}
}
temp = list()
temp[[runningNode[['label']]]] <- runningNode
visitedNodes = append(visitedNodes, temp)
runningNode = nearestUnvisitedNeighbor(nodes, visitedNodes, runningNode)
}
heat = data.frame('label' = labels, 'heat' = ndensity)
if(abs(nodes[[1]][['lat']]) <= 180) {
warning("Distance may be calculated in the degree coordinates, which may need to be projected into other distance units")
}
return(heat)
}
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
result = NDScanManhattan(nodes, edges, 1000, 4)
#------------------------------------------#
#-----------Utility Methods ---------------#
#------------------------------------------#
#Get number of nodes within manhattan distance of source node
numberNodesWithinManhattanDistance = function(nodes, source, distance) {
retValue = 0
for (node in nodes) {
dist = ManhattanDistance(source, node)
if (dist < distance) {retValue = retValue + 1}
}
return (retValue)
}
#Get number of edges within manhattan distance of source node
numberEdgesWithinManhattanDistance = function(nodes, edges, source, distance) {
retValue = 0
for (edge in edges) {
dist1 = ManhattanDistance(source, nodes[[edge[['Source']]]])
dist2 = ManhattanDistance(source, nodes[[edge[['Target']]]])
if (dist1 < distance & dist2 < distance) {
retValue = retValue + 1
}
}
return(retValue)
}
#Get the list of nodes within manhattan distance of source node
getNodesInManhattanDistance = function (nodes, source, distance) {
retNodes = c()
for (node in nodes) {
dist = ManhattanDistance(source, node)
if (dist < distance) {
retNodes = append(retNodes, node)
}
}
return (retNodes)
}
#Get the list of edges within manhattan distance of source node
getEdgesInManhattanDistance = function(nodes, edges, source, distance) {
retList = c()
for (edge in edges) {
if (testEdgeInRange(nodes, edge, source, distance)) {
retList = append(retList, edge)
}
}
return (retList)
}
#Determines if two nodes are equal based on having same coordinates
nodeEquals = function(node1, node2) {
if ((node1[['lat']] == node2[['lat']]) & (node1[['lon']] == node2[['lon']])) {
return (TRUE)
} else {
return (FALSE)
}
}
#Determines if two edges are equal based on consisting of same two nodes in either direction
edgeEquals = function(edge1, edge2, nodes) {
if ((nodeEquals(nodes[[edge1[['Source']]]], nodes[[edge2[['Source']]]]) & nodeEquals(nodes[[edge1[['Target']]]], nodes[[edge2[['Target']]]])) |
(nodeEquals(nodes[[edge1[['Source']]]], nodes[[edge2[['Target']]]]) & nodeEquals(nodes[[edge1[['Target']]]], nodes[[edge2[['Source']]]]))) {
return (TRUE)
} else {
return (FALSE)
}
}
#Get Manhattan distance between two nodes
ManhattanDistance = function(node1, node2) {
return (abs(node1[['lat']] - node2[['lat']]) + abs(node1[['lon']] - node2[['lon']]))
}
#Get Euclidean distance between two nodes
euclidDistance = function(node1, node2) {
return (sqrt((node1[['lat']] - node2[['lat']]) ** 2 + (node1[['lon']]-node2[['lon']]) ** 2))
}
#Calculate midpoint of an edge
#edge is a 1*2 tibble that has source and target as node names. nodes is the full node list.
calculateMidpoint = function(edge, nodes) {
source = edge[['Source']]
target = edge[['Target']]
x = (max(nodes[[source]][['lat']], nodes[[target]][['lat']]) + min(nodes[[source]][['lat']], nodes[[target]][['lat']])) / 2
y = (max(nodes[[source]][['lon']], nodes[[target]][['lon']]) + min(nodes[[source]][['lon']], nodes[[target]][['lon']])) / 2
return(x,y)
}
#Get a certain number of the nearest neighbor hodes to a source node (can suggest increasing the number if numNeighbors > number)
nearestNeighbors = function(nodes, source, number) {
neighbors = list() #a particular structure to store tibble nodes #dict does not accept tibble as the key
distance_dict = {}
numNeighbors = 0
for (node in nodes) {
label = node[['label']]
if (node[['label']] != source[['label']]) {
distance = euclidDistance(source, node)
if (numNeighbors < number) {
temp = list()
temp[[label]] <- node
neighbors = append(neighbors, temp)
distance_dict[label] = distance
numNeighbors = numNeighbors + 1
} else {
for (neighbor in neighbors) {
neigh_label = neighbor[['label']]
if (distance < distance_dict[neigh_label]) {
neighbors = neighbors[names(neighbors) != neigh_label]
temp = list()
temp[[label]] <- node
neighbors = append(neighbors, temp)
distance_dict[label] = distance
break
}
}
}
}
}
return(neighbors) #a list of named lists
}
#Get the nearest neighbor to a source node that is not in the visited list
nearestUnvisitedNeighbor = function(nodes, visited, source) {
minNode = NULL
minDistance = -1
for (node in nodes) {
if (node[['label']] != source[['label']] & (!node[['label']] %in% names(visited))) {
distance = euclidDistance(source, node)
if (minDistance == -1 | distance < minDistance) {
minDistance = distance
minNode = node
}
}
}
return(minNode)
}
#Get all the nodes within a certain radius of a source node
nodesWithinRadius = function(nodes, source, radius) {
retNodes = list()
for (node in nodes) {
distance = euclidDistance(source, node)
if (distance < radius) {
label = node[['label']]
temp = list()
temp[[label]] <- node
retNodes = append(retNodes, temp)
}
}
return(retNodes)
}
numberNodesWithinRadius = function(nodes, source, radius) {
numNodes = 0
for (node in nodes) {
distance = euclidDistance(source, node)
if (distance < radius) {
numNodes = numNodes + 1
}
}
return (numNodes)
}
#Tests if an edge is fully within a radius of a given node
testEdgeInRange = function(nodes, edge, node, radius) {
edgeSource = edge[['Source']]
edgeTarget = edge[['Target']]
if (is.null(nodes[[edgeSource]]) | is.null(nodes[[edgeTarget]])) {
stop('Cannot find edge source or target in the node table. Please filter your edge table to contain edges that have corresponding nodes in the node table, or double check whether your node label column has the same values as edge source and target columns.')
} else {
if (euclidDistance(node, nodes[[edgeSource]]) < radius & euclidDistance(node, nodes[[edgeTarget]]) < radius) {
return (TRUE)
} else {
return (FALSE)
}
}
}
#Gets the number of edges within a radius of a given node
getNumEdgesInRange = function(nodes, edges, node, radius) {
retVal = 0
for (edge in edges) {
if (testEdgeInRange(nodes, edge, node, radius)) {
retVal = retVal + 1
}
}
return (retVal)
}
#Gets the list of edges within a radius of a given node
getEdgesInRange = function(nodes, edges, node, radius) {
retList = list()
for (edge in edges) {
if (testEdgeInRange(nodes, edge, node, radius)) {
retList[[length(retList) + 1]] = edge
}
}
return (retList)
}
#Tests if there is an edge between two given nodes
edgeExists = function(edges, nodes, node1, node2) {
edge2 = list('Source' = node1[['label']], 'Target' = node2[['label']])
for (edge in edges) {
if (edgeEquals(edge, edge2, nodes)) {
return (TRUE)
} else {
return (FALSE)
}
}
}
#Generates the adjacency matrix for a graph of nodes and edges
getAdjacencyMatrix = function(nodes, edges) {
dim = length(nodes)
adj = matrix(c(0), nrow=dim, ncol=dim)
i = 0
for (node in nodes) {
j = 0
for (node2 in nodes) {
if (edgeExists(edges, nodes, node, node2)) {
adj[i][j] = 1
adj[j][i] = 1
}
j = j + 1
}
}
for (i in 1:dim) {
adj[i][i] = 0
}
return (adj)
}
multiply = function(A, B, C) {
V = nrow(A)
for (i in 1:V) {
for (j in 1:V) {
C[i][j] = 0
for (k in 1:V) {
C[i][j] = C[i][j] + A[i][k] * B[k][j]
}
}
}
}
# Utility function to calculate trace of a matrix (sum of diagnonal elements)
getTrace = function(graph) {
V = nrow(graph)
trace = 0
for (i in 1:V) {
trace = trace + graph[i][i]
}
return (trace)
}
# Utility function for calculating number of triangles in graph
triangleInGraph = function(graph) {
V = nrow(graph)
aux2 = matrix(c(0), nrow=V, ncol=V)
aux3 = matrix(c(0), nrow=V, ncol=V)
# aux2 is graph^2 now printMatrix(aux2)
multiply(graph, graph, aux2)
# after this multiplication aux3 is
# graph^3 printMatrix(aux3)
multiply(graph, aux2, aux3)
trace = getTrace(aux3)
return (floor(trace / 6))
}
result = NDScanManhattan(nodes, edges, 1000, 4)
View(result)
result = NDScanManhattan(nodes, edges, 1000, 2)
nodes = processNode(NYCMafiaNodes, 'label', 'LonX', 'LatY')
edges = processEdge(NYCMafiaEdges, 'Source', 'Target')
result = NDScanManhattan(nodes, edges, 1000, 2)
